"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Cipher_1 = require("./Cipher");
var keys = require("../keys");
var cipherUtil_1 = require("./cipherUtil");
var util_1 = require("./../util");
var _ = require("lodash");
var Amsco = (function (_super) {
    __extends(Amsco, _super);
    function Amsco() {
        _super.apply(this, arguments);
        this.name = "Amsco";
        this.keyInfo = new keys.NumericArrangement();
    }
    Amsco.prototype.getAmscoBoxes = function (str, startOdd) {
        if (startOdd) {
            return [str[0]].concat(this.getAmscoBoxes(str.slice(1), false));
        }
        return _.chain(str.split(""))
            .chunk(3)
            .map(function (arr) { return _.chunk(arr, 2).map(function (x) { return x.join(""); }); })
            .flatten()
            .value();
    };
    Amsco.prototype.getAmscoColumnsFromPlaintext = function (input, keyLength) {
        return cipherUtil_1.transpose(_.chain(input.split(""))
            .chunk(3)
            .map(function (arr) { return _.chunk(arr, 2).map(function (x) { return x.join(""); }); })
            .flatten()
            .chunk(keyLength)
            .value());
    };
    Amsco.prototype.getAmscoColumnsFromCiphertext = function (input, key) {
        var _this = this;
        var columnLengthsByCiphertextOrder = this.findAmscoColumnLengths(input.length, key.length);
        var inverseKey = cipherUtil_1.inversePermutation(key);
        var columnLengthsByPlaintextOrder = cipherUtil_1.undoPermutation(columnLengthsByCiphertextOrder, key);
        var nonBoxedColumns = cipherUtil_1.divideBy(input, columnLengthsByPlaintextOrder);
        return nonBoxedColumns.map(function (x, i) { return _this.getAmscoBoxes(x, inverseKey[i] % 2 == 1); });
    };
    Amsco.prototype.findAmscoColumnLengths = function (inputLength, keyLength) {
        var columnLengths = util_1.generateUniformArray(0, keyLength);
        var boxPosition = 0;
        for (var stringPosition = 0; stringPosition < inputLength; boxPosition++) {
            if (boxPosition % 2 == 1) {
                stringPosition++;
                columnLengths[boxPosition % keyLength]++;
            }
            else {
                if (stringPosition + 2 <= inputLength) {
                    stringPosition += 2;
                    columnLengths[boxPosition % keyLength] += 2;
                }
                else {
                    stringPosition++;
                    columnLengths[boxPosition % keyLength]++;
                }
            }
        }
        return columnLengths;
    };
    Amsco.prototype.rawDecrypt = function (input, key) {
        return _.flatten(cipherUtil_1.transpose(cipherUtil_1.applyPermutation(this.getAmscoColumnsFromCiphertext(input, key), key))).join("");
    };
    Amsco.prototype.rawEncrypt = function (input, key) {
        return _.flatten(cipherUtil_1.undoPermutation(this.getAmscoColumnsFromPlaintext(input, key.length), key)).join("");
    };
    return Amsco;
}(Cipher_1.Cipher));
module.exports = Amsco;
//# sourceMappingURL=Amsco.js.map