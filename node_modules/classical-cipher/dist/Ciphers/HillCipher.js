"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Cipher_1 = require("./Cipher");
var keys = require("../keys");
var cipherUtil_1 = require("./cipherUtil");
var util_1 = require("./../util");
var InvalidKeyException_1 = require("./../Keys/InvalidKeyException");
var _ = require("lodash");
var hillCiphersInverses = [NaN, 1, NaN, 9, NaN, 21, NaN, 15, NaN, 3, NaN, 19, NaN, NaN, NaN, 7, NaN, 23, NaN, 11, NaN, 5, NaN, 17, NaN, 25];
function isValidKey(key) {
    var det = cipherUtil_1.cMod(key[0] * key[3] - key[1] * key[2], 26);
    var inverseDet = hillCiphersInverses[det];
    if (isNaN(inverseDet))
        return false;
    return true;
}
var HillCipherKey = (function (_super) {
    __extends(HillCipherKey, _super);
    function HillCipherKey() {
        _super.call(this, _.range(0, 25), 4);
    }
    HillCipherKey.prototype.getPrimitiveKey = function (key) {
        var potentialKey = _super.prototype.getPrimitiveKey.call(this, key);
        if (!isValidKey(potentialKey))
            throw new InvalidKeyException_1.default(key, "is not invertable");
        return potentialKey;
    };
    HillCipherKey.prototype.generateRandom = function () {
        while (true) {
            var potentialKey = _super.prototype.generateRandom.call(this);
            if (isValidKey(potentialKey)) {
                return potentialKey;
            }
        }
    };
    HillCipherKey.prototype.generateOrdered = function (prev) {
        throw new util_1.NotImplementedException();
    };
    return HillCipherKey;
}(keys.NonUniqueFixedLengthArray));
var HillCipher = (function (_super) {
    __extends(HillCipher, _super);
    function HillCipher() {
        _super.apply(this, arguments);
        this.name = "Hill Cipher";
        this.keyInfo = (new HillCipherKey());
    }
    HillCipher.prototype.rawEncrypt = function (input, key) {
        var retValue = "";
        var matrixDimentions = Math.sqrt(key.length);
        if (input.length % matrixDimentions !== 0)
            throw Error("Input not a muliple of " + matrixDimentions);
        for (var i = 0; i < input.length; i += 2) {
            var nGram = input.slice(i, i + matrixDimentions).split("");
            var numNGram = nGram.map(function (el) { return util_1.toLetterCode(el); });
            for (var x = 0; x < matrixDimentions; x++) {
                var sum = 0;
                for (var y = 0; y < matrixDimentions; y++) {
                    sum += key[y + x * matrixDimentions] * numNGram[y];
                }
                retValue += util_1.fromLetterCode(cipherUtil_1.cMod(sum, 26));
            }
        }
        return retValue;
    };
    HillCipher.prototype.rawDecrypt = function (input, key) {
        var retValue = "";
        if (input.length % 2 !== 0)
            throw Error("Input not a muliple of 2");
        var det = cipherUtil_1.cMod(key[0] * key[3] - key[1] * key[2], 26);
        var inverseDet = hillCiphersInverses[det];
        if (isNaN(inverseDet))
            return "";
        for (var i = 0; i < input.length; i += 2) {
            var biGram = input.slice(i, i + 2);
            var numBiGram = [util_1.toLetterCode(biGram[0]), util_1.toLetterCode(biGram[1])];
            retValue += util_1.fromLetterCode(cipherUtil_1.cMod((key[3] * numBiGram[0] - key[1] * numBiGram[1]) * inverseDet, 26));
            retValue += util_1.fromLetterCode(cipherUtil_1.cMod((-key[2] * numBiGram[0] + key[0] * numBiGram[1]) * inverseDet, 26));
        }
        return retValue;
    };
    return HillCipher;
}(Cipher_1.Cipher));
module.exports = HillCipher;
//# sourceMappingURL=HillCipher.js.map