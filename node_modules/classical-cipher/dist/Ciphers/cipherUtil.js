"use strict";
var _ = require("lodash");
function letterCodeOutputMap(input, func) {
    var output = "";
    for (var i = 0; i < input.length; i++) {
        output += String.fromCharCode(func(input[i], i) + 65);
    }
    return output;
}
exports.letterCodeOutputMap = letterCodeOutputMap;
function divideBy(str, pattern) {
    var previousSlicePosition = 0;
    var nextSlicePosition;
    var slices = pattern.map(function (nextSliceLength) {
        nextSlicePosition = previousSlicePosition + nextSliceLength;
        var slice = str.slice(previousSlicePosition, nextSlicePosition);
        previousSlicePosition = nextSlicePosition;
        return slice;
    });
    if (nextSlicePosition != str.length - 1) {
        slices.push(str.slice(nextSlicePosition));
    }
    return slices;
}
exports.divideBy = divideBy;
function letterCodeInputMap(input, func) {
    var output = "";
    for (var i = 0; i < input.length; i++) {
        output += func(input[i].charCodeAt(0) - 65, i);
    }
    return output;
}
exports.letterCodeInputMap = letterCodeInputMap;
function letterCodeMap(input, func) {
    var output = "";
    for (var i = 0; i < input.length; i++) {
        var charCode = input[i].charCodeAt(0);
        output += String.fromCharCode(func(charCode - 65, i) + 65);
    }
    return output;
}
exports.letterCodeMap = letterCodeMap;
function cMod(num, base) {
    return num > 0 ? num % base : (base + ((num) % base)) % base;
}
exports.cMod = cMod;
function undoPermutation(arr, permutation) {
    return _.sortBy(_.zip(arr, permutation), 1).map(function (x) { return x[0]; });
}
exports.undoPermutation = undoPermutation;
function inversePermutation(permutation) {
    return undoPermutation(_.range(0, permutation.length), permutation);
}
exports.inversePermutation = inversePermutation;
function applyPermutation(arr, permutation) {
    var minElement = _.min(permutation);
    return permutation.map(function (num) { return arr[num - minElement]; });
}
exports.applyPermutation = applyPermutation;
function transpose(arr) {
    return _.zip.apply(_, arr);
}
exports.transpose = transpose;
function cantorTuple(tuple) {
    if (tuple.length == 1) {
        return tuple[0];
    }
    return cantorPairing(cantorTuple(_.tail(tuple)), _.head(tuple));
}
exports.cantorTuple = cantorTuple;
function inverseCantorTuple(num, n) {
    if (n == 1) {
        return [num];
    }
    var pair = inverseCantorPairing(num);
    return [pair[0]].concat(inverseCantorTuple(pair[1], n - 1));
}
exports.inverseCantorTuple = inverseCantorTuple;
function inverseCantorPairing(n) {
    if (n < 0)
        return null;
    var w = Math.floor((Math.sqrt(8 * n + 1) - 1) / 2);
    var t = (w * w + w) / 2;
    var y = n - t;
    var x = w - y;
    return [x, y];
}
exports.inverseCantorPairing = inverseCantorPairing;
function cantorPairing(n1, n2) {
    return 1 / 2 * (n1 + n2) * (n1 + n2 + 1) + n2;
}
exports.cantorPairing = cantorPairing;
//# sourceMappingURL=cipherUtil.js.map