"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Solver_1 = require("../Solvers/Solver");
var _ = require("lodash");
function hill_climbing(init, progress, weight) {
    var curr_value = _.cloneDeep(init);
}
var HillClimbing = (function (_super) {
    __extends(HillClimbing, _super);
    function HillClimbing() {
        _super.apply(this, arguments);
        this.name = "Hill Climbing";
    }
    HillClimbing.prototype.rawSolve = function (args) {
        _.defaults(args.settings, {
            needToPassBenchmark: true,
            initKey: args.cipher.keyInfo.generateRandom(),
            iterations: 1000
        });
        var bestKey = args.settings.initKey;
        var bestWeight = args.stat.lowerIsBetter ? Infinity : -Infinity;
        for (var tryNum = 0; tryNum < 10000; tryNum++) {
            var currKey = args.cipher.keyInfo.smallAlteration(bestKey);
            var decryptedText = args.cipher.decrypt(args.cipherText, currKey);
            var keyWeight = args.stat.findStatistic(decryptedText);
            if (args.stat.lowerIsBetter == keyWeight < bestWeight) {
                bestWeight = keyWeight;
                bestKey = currKey;
                args.reporter.log("Found new key: " + currKey + " text " + decryptedText.slice(0, 100) + ", of weight " + keyWeight);
            }
        }
        return {
            text: args.cipher.decrypt(args.cipherText, bestKey),
            key: bestKey
        };
    };
    return HillClimbing;
}(Solver_1.Solver));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HillClimbing;
//# sourceMappingURL=HillClimbing.js.map